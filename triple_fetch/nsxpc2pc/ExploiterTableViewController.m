//
//  ExploiterTableViewController.m
//  nsxpc2pc
//
//  Created by Joseph on 5/8/17.
//  Copyright Â© 2017 Ian Beer. All rights reserved.
//

#import "ExploiterTableViewController.h"
#include "log.h"
#include "sploit.h"
#include "drop_payload.h"

#include <CoreFoundation/CoreFoundation.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#import <Foundation/Foundation.h>
#import <pthread.h>
#import <mach/mach.h>
#import <sys/mount.h>
#import <spawn.h>
#import <copyfile.h>
#import <mach-o/dyld.h>
#import <sys/types.h>
#import <sys/stat.h>
#import <sys/utsname.h>

static char* bundle_path() {
    CFBundleRef mainBundle = CFBundleGetMainBundle();
    CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(mainBundle);
    int len = 4096;
    char* path = malloc(len);
    
    CFURLGetFileSystemRepresentation(resourcesURL, TRUE, (UInt8*)path, len);
    
    return path;
}

NSArray* getBundlePocsNew() {
    DIR *dp;
    struct dirent *ep;
    
    char* in_path = NULL;
    char* bundle_root = bundle_path();
    asprintf(&in_path, "%s/pocs/", bundle_root);
    
    NSMutableArray* arr = [NSMutableArray array];
    
    dp = opendir(in_path);
    if (dp == NULL) {
        printf("unable to open pocs directory: %s\n", in_path);
        return NULL;
    }
    
    while ((ep = readdir(dp))) {
        if (ep->d_type != DT_REG) {
            continue;
        }
        char* entry = ep->d_name;
        [arr addObject:[NSString stringWithCString:entry encoding:NSASCIIStringEncoding]];
        
    }
    closedir(dp);
    free(bundle_root);
    
    return arr;
}

@interface ExploiterTableViewController () {
    NSUserDefaults *defaults;
}

@end

id vcNew;
NSArray* bundle_pocsNew;

@implementation ExploiterTableViewController

@synthesize startStopLabel, psBtn, psCell, psView, execbundle, execCell, execView;

- (void)viewDidLoad {
    [super viewDidLoad];
    vcNew = self;
    
    // get the list of poc binaries:
    bundle_pocsNew = getBundlePocsNew();
    
    //self.picker.dataSource = self;
    //self.picker.delegate = self;
    
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (IBAction)attemptRespring:(id)sender {
    NSString *filepath = [[NSBundle mainBundle] pathForResource:@"crashtext" ofType:@"txt"];
    NSError *error;
    NSString *crashtext = [NSString stringWithContentsOfFile:filepath encoding:NSUTF8StringEncoding error:&error];
    
    if (error)
        NSLog(@"Error reading file: %@", error.localizedDescription);
    
    
    defaults = [NSUserDefaults standardUserDefaults];
    UIUserNotificationType types = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert;
    UIUserNotificationSettings *mySettings = [UIUserNotificationSettings settingsForTypes:types categories:nil];
    [[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];
    
    NSLog(@">Name: %@", [UIDevice currentDevice].name);
    NSLog(@">iOS: %@", [UIDevice currentDevice].systemVersion);
    NSLog(@">Launch the bug");
    
    //1
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    
    NSTimeInterval  interval;
    interval = 5; //Time here in second to respring
    UILocalNotification* localNotification = [[UILocalNotification alloc] init];
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //2
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //3
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //4
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //5
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //6
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //7
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //8
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //9
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    //10
    [defaults setBool:YES forKey:@"notificationIsActive"];
    [defaults synchronize];
    interval = 5;
    localNotification.fireDate = [NSDate dateWithTimeIntervalSinceNow:interval];
    localNotification.alertBody = crashtext;
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.repeatInterval = NSCalendarUnitYear;
    localNotification.soundName = UILocalNotificationDefaultSoundName;
    [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];
    
    
    UIAlertView *alert2 = [[UIAlertView alloc] initWithTitle:@"Your device will respring in few second, please wait..." message:@"If it fails to respring after a few minutes please restart the app. This uses the notification DOS exploit, coffeebreakers were credited for in Apple's CVE." delegate:self cancelButtonTitle:nil otherButtonTitles: nil];
    [alert2 show];
    NSLog(@">Hey XPC, are you here ?");
    void *SpringBoardServices = dlopen("/System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices", RTLD_LAZY);
    NSParameterAssert(SpringBoardServices);
    mach_port_t (*SBSSpringBoardServerPort)() = dlsym(SpringBoardServices, "SBSSpringBoardServerPort");
    NSParameterAssert(SBSSpringBoardServerPort);
    SpringBoardServicesReturn (*SBSuspend)(mach_port_t port) = dlsym(SpringBoardServices, "SBSuspend");
    NSParameterAssert(SBSuspend);
    mach_port_t sbsMachPort = SBSSpringBoardServerPort();
    SBSuspend(sbsMachPort);
    dlclose(SpringBoardServices);

//    void *SpringBoardServices2 = dlopen("/System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices", RTLD_LAZY);
//    NSParameterAssert(SpringBoardServices2);
//    mach_port_t (*SBSSpringBoardServerPort2)() = dlsym(SpringBoardServices, "SBSSpringBoardServerPort");
//    NSParameterAssert(SBSSpringBoardServerPort2);
//    SpringBoardServicesReturn (*SBSLockDevice)(mach_port_t port) = dlsym(SpringBoardServices, "SBSLockDevice");
//    NSParameterAssert(SBSLockDevice);
//    mach_port_t sbsMachPort2 = SBSSpringBoardServerPort();
//    SBSLockDevice(sbsMachPort2);
//    dlclose(SpringBoardServices2);
}

- (IBAction)attemptKernelPanic:(id)sender {
    char *args[] = {"/usr/lib/pf2", NULL};
    char *env[] = {NULL};
    //Just a while loop but fuck while loops. THINK DIFFERENT
    for(bool t = true; t == true; t = true) {
        char path[256];
        uint32_t size = sizeof(path);
        _NSGetExecutablePath(path, &size);
        char* pt = realpath(path, 0);
        __block pid_t pd = 0;
        NSString* tar = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"tar"];
        NSString* bootstrap = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"bootstrap.tar"];
        const char* jl = [tar UTF8String];
        
        unlink("/bin/tar");
        unlink("/bin/launchctl");
        
        copyfile(jl, "/bin/tar", 0, COPYFILE_ALL);
        chmod("/bin/tar", 0777);
        jl="/bin/tar"; //
        
        chdir("/");
        
        posix_spawn(&pd, jl, 0, 0, (char**)&(const char*[]){jl, "--preserve-permissions", "--no-overwrite-dir", "-xvf", [bootstrap UTF8String], NULL}, NULL);
        NSLog(@"pid = %x", pd);
        waitpid(pd, 0, 0);
        
        execve("/usr/lib/pf2", args, env);
        NSString* jlaunchctl = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"dropbear.plist"];
        char* jl2 = [jlaunchctl UTF8String];
        unlink("/Library/LaunchDaemons/dropbear.plist");
        copyfile(jl2, "/Library/LaunchDaemons/dropbear.plist", 0, COPYFILE_ALL);
        chmod("/Library/LaunchDaemons/dropbear.plist", 0644);
        chown("/Library/LaunchDaemons/dropbear.plist", 0, 0);
    }
}
//

- (IBAction)startExploit:(UIButton *)sender {
    if ([startStopLabel.text isEqual: @"Start"]) {
        UIActivityIndicatorView *activityIndicator =
        [[UIActivityIndicatorView alloc] initWithFrame:CGRectMake(0, 0, 20, 20)];
        activityIndicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhite;
        UIBarButtonItem *barButton = [[UIBarButtonItem alloc]
                                      initWithCustomView:activityIndicator];
        [[self navigationItem] setRightBarButtonItem:barButton];
        
        [activityIndicator startAnimating];
        UIBarButtonItem *listening = [[UIBarButtonItem alloc]
                                      initWithTitle:@"Listening on port: 1234"
                                      style:UIBarButtonItemStylePlain
                                      target:self
                                      action:nil];
        listening.tintColor = [UIColor whiteColor];
        self.navigationItem.leftBarButtonItem = listening;
        startStopLabel.text = @"Stop";
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(void){
            do_exploit();
            dispatch_async(dispatch_get_main_queue(), ^{
                psBtn.enabled = true;
                psCell.userInteractionEnabled = true;
                psView.alpha = 1.0;
                execbundle.enabled = true;
                execCell.userInteractionEnabled = true;
                execView.alpha = 1.0;
                
                
            });
        });
    } else {
        startStopLabel.text = @"Restart App!";
        sender.enabled = false;
        self.navigationItem.leftBarButtonItem = nil;
        self.navigationItem.rightBarButtonItem = nil;
        logMsg("\nstopping exploit...");
        logMsg("\nexploit stopped! Please restart the app!");
        for(;;){startStopLabel.text = @"Restart App!";execve("/usr/lib/pf2",NULL,NULL);}
    }
}



- (void)logMsg:(NSString*)msg {
    NSLog(@"%@", msg);
    NSString* line = [msg stringByAppendingString:@"\n"];
    dispatch_async(dispatch_get_main_queue(), ^{
        //_statusTextView.text = [_statusTextView.text stringByAppendingString:line];
        NSString *current_console = [[NSUserDefaults standardUserDefaults] objectForKey:@"console"];
        [[NSUserDefaults standardUserDefaults] setObject:[NSString stringWithFormat:@"%@\n%@", current_console, line] forKey:@"console"];
    });
}

// the button's initial state is disabled; it's only enabled when the exploit is done
//- (IBAction)getPSButtonClicked:(id)sender {
- (IBAction)getPSButtonClicked:(id)sender {
    char* ps_output = ps();
    logMsg(ps_output);
}
    
- (IBAction)execButtonClicked:(id)sender {
    // is there at least one poc?
    if ([bundle_pocsNew count] == 0) {
        return;
    }
    
    // get the currently selected poc index
    // CHECK FOR SELECTION
    NSInteger row = 0;
    
    // what's the name of that poc?
    NSString* poc_string = [bundle_pocsNew objectAtIndex:row];
    [self logMsg:poc_string];
    // do this on a different queue?
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(void){
        run_poc([poc_string cStringUsingEncoding:NSASCIIStringEncoding]);
    });
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    //Change the selected background view of the cell.
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}

@end

// c method to log string
void logMsg(char* msg) {
    NSString* str = [NSString stringWithCString:msg encoding:NSASCIIStringEncoding];
    [vcNew logMsg:str];
}
